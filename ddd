<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D BedWars</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #1a237e, #0d47a1);
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h2>BedWars</h2>
            <p>Health: <span id="health">100</span></p>
            <p>Enemies: <span id="enemies">0</span></p>
            <p>Resources: <span id="resources">50</span></p>
            <p>Wave: <span id="wave">1</span></p>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Your bed was destroyed!</p>
            <p>You survived <span id="finalWave">0</span> waves</p>
            <button id="restartButton">Play Again</button>
        </div>
        
        <div id="instructions">
            <p>WASD: Move | Mouse: Look | Left Click: Attack | R: Build Defense</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let player, bed, enemies = [], defenses = [];
        let health = 100;
        let resources = 50;
        let wave = 1;
        let gameOver = false;
        
        // Movement variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            // Create player (simple cube for now)
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 1, 0);
            scene.add(player);
            
            // Create bed
            const bedGeometry = new THREE.BoxGeometry(3, 0.5, 2);
            const bedMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
            bed = new THREE.Mesh(bedGeometry, bedMaterial);
            bed.position.set(0, 0.25, -5);
            scene.add(bed);
            
            // Add event listeners
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('click', onMouseClick, false);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            window.addEventListener('resize', onWindowResize, false);
            
            // Start game loop
            animate();
            
            // Start enemy spawning
            spawnEnemies();
        }
        
        // Handle key down events
        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyR':
                    buildDefense();
                    break;
            }
        }
        
        // Handle key up events
        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }
        
        // Handle mouse click for attacking
        function onMouseClick() {
            if (gameOver) return;
            
            // Simple attack logic - damage nearby enemies
            enemies.forEach((enemy, index) => {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 5) {
                    // Remove enemy
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                    resources += 5;
                    updateUI();
                }
            });
        }
        
        // Build defense structure
        function buildDefense() {
            if (resources < 10 || gameOver) return;
            
            resources -= 10;
            updateUI();
            
            const defenseGeometry = new THREE.BoxGeometry(2, 2, 2);
            const defenseMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const defense = new THREE.Mesh(defenseGeometry, defenseMaterial);
            
            // Position defense near player
            defense.position.copy(player.position);
            defense.position.x += Math.random() * 6 - 3;
            defense.position.z += Math.random() * 6 - 3;
            
            scene.add(defense);
            defenses.push(defense);
        }
        
        // Spawn enemies
        function spawnEnemies() {
            if (gameOver) return;
            
            const enemyCount = wave * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    if (gameOver) return;
                    
                    const enemyGeometry = new THREE.BoxGeometry(1, 1.5, 1);
                    const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    
                    // Position enemy at random edge of map
                    const side = Math.floor(Math.random() * 4);
                    let x, z;
                    
                    switch(side) {
                        case 0: // Top
                            x = Math.random() * 80 - 40;
                            z = -40;
                            break;
                        case 1: // Right
                            x = 40;
                            z = Math.random() * 80 - 40;
                            break;
                        case 2: // Bottom
                            x = Math.random() * 80 - 40;
                            z = 40;
                            break;
                        case 3: // Left
                            x = -40;
                            z = Math.random() * 80 - 40;
                            break;
                    }
                    
                    enemy.position.set(x, 0.75, z);
                    scene.add(enemy);
                    enemies.push(enemy);
                    updateUI();
                }, i * 1000); // Stagger enemy spawns
            }
            
            // Schedule next wave
            setTimeout(() => {
                if (!gameOver) {
                    wave++;
                    updateUI();
                    spawnEnemies();
                }
            }, enemyCount * 1000 + 5000); // 5 seconds after last enemy spawn
        }
        
        // Update game state
        function update() {
            if (gameOver) return;
            
            // Player movement
            const speed = 0.1;
            if (moveForward) player.position.z -= speed;
            if (moveBackward) player.position.z += speed;
            if (moveLeft) player.position.x -= speed;
            if (moveRight) player.position.x += speed;
            
            // Keep player within bounds
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));
            
            // Update camera to follow player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 10;
            camera.lookAt(player.position.x, player.position.y, player.position.z);
            
            // Enemy AI - move toward bed
            enemies.forEach((enemy, index) => {
                const direction = new THREE.Vector3();
                direction.subVectors(bed.position, enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(0.03));
                
                // Check if enemy reached the bed
                if (enemy.position.distanceTo(bed.position) < 2) {
                    // Damage bed
                    health -= 10;
                    updateUI();
                    
                    // Remove enemy
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                    
                    // Check for game over
                    if (health <= 0) {
                        health = 0;
                        gameOver = true;
                        document.getElementById('finalWave').textContent = wave;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                }
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        
        // Update UI elements
        function updateUI() {
            document.getElementById('health').textContent = health;
            document.getElementById('enemies').textContent = enemies.length;
            document.getElementById('resources').textContent = resources;
            document.getElementById('wave').textContent = wave;
        }
        
        // Restart game
        function restartGame() {
            // Reset game state
            health = 100;
            resources = 50;
            wave = 1;
            gameOver = false;
            
            // Remove all enemies and defenses
            enemies.forEach(enemy => scene.remove(enemy));
            defenses.forEach(defense => scene.remove(defense));
            enemies = [];
            defenses = [];
            
            // Reset player and bed positions
            player.position.set(0, 1, 0);
            bed.position.set(0, 0.25, -5);
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Update UI and restart enemy spawning
            updateUI();
            spawnEnemies();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
